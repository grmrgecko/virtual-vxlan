// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.2
// source: vxlan/vxlan.proto

package vxlan

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Vxlan_SaveConfig_FullMethodName                 = "/vxlan.vxlan/SaveConfig"
	Vxlan_ReloadConfig_FullMethodName               = "/vxlan.vxlan/ReloadConfig"
	Vxlan_IsApplyingConfig_FullMethodName           = "/vxlan.vxlan/IsApplyingConfig"
	Vxlan_ListListeners_FullMethodName              = "/vxlan.vxlan/ListListeners"
	Vxlan_AddListener_FullMethodName                = "/vxlan.vxlan/AddListener"
	Vxlan_RemoveListener_FullMethodName             = "/vxlan.vxlan/RemoveListener"
	Vxlan_SetListenerMaxMessageSize_FullMethodName  = "/vxlan.vxlan/SetListenerMaxMessageSize"
	Vxlan_GetListenerMaxMessageSize_FullMethodName  = "/vxlan.vxlan/GetListenerMaxMessageSize"
	Vxlan_ListInterfaces_FullMethodName             = "/vxlan.vxlan/ListInterfaces"
	Vxlan_AddInterface_FullMethodName               = "/vxlan.vxlan/AddInterface"
	Vxlan_RemoveInterface_FullMethodName            = "/vxlan.vxlan/RemoveInterface"
	Vxlan_SetInterfaceMTU_FullMethodName            = "/vxlan.vxlan/SetInterfaceMTU"
	Vxlan_GetInterfaceMTU_FullMethodName            = "/vxlan.vxlan/GetInterfaceMTU"
	Vxlan_SetInterfaceMACAddress_FullMethodName     = "/vxlan.vxlan/SetInterfaceMACAddress"
	Vxlan_GetInterfaceMACAddress_FullMethodName     = "/vxlan.vxlan/GetInterfaceMACAddress"
	Vxlan_SetInterfaceIPAddresses_FullMethodName    = "/vxlan.vxlan/SetInterfaceIPAddresses"
	Vxlan_GetInterfaceIPAddresses_FullMethodName    = "/vxlan.vxlan/GetInterfaceIPAddresses"
	Vxlan_InterfaceAddMACEntry_FullMethodName       = "/vxlan.vxlan/InterfaceAddMACEntry"
	Vxlan_InterfaceRemoveMACEntry_FullMethodName    = "/vxlan.vxlan/InterfaceRemoveMACEntry"
	Vxlan_InterfaceGetMACEntries_FullMethodName     = "/vxlan.vxlan/InterfaceGetMACEntries"
	Vxlan_InterfaceFlushMACTable_FullMethodName     = "/vxlan.vxlan/InterfaceFlushMACTable"
	Vxlan_InterfaceAddStaticRoute_FullMethodName    = "/vxlan.vxlan/InterfaceAddStaticRoute"
	Vxlan_InterfaceRemoveStaticRoute_FullMethodName = "/vxlan.vxlan/InterfaceRemoveStaticRoute"
	Vxlan_InterfaceGetStaticRoutes_FullMethodName   = "/vxlan.vxlan/InterfaceGetStaticRoutes"
	Vxlan_InterfaceAddStaticARPEntry_FullMethodName = "/vxlan.vxlan/InterfaceAddStaticARPEntry"
	Vxlan_InterfaceRemoveARPEntry_FullMethodName    = "/vxlan.vxlan/InterfaceRemoveARPEntry"
	Vxlan_InterfaceGetARPEntries_FullMethodName     = "/vxlan.vxlan/InterfaceGetARPEntries"
	Vxlan_InterfaceFlushARPTable_FullMethodName     = "/vxlan.vxlan/InterfaceFlushARPTable"
)

// VxlanClient is the client API for Vxlan service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VxlanClient interface {
	// Config commands.
	SaveConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	ReloadConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	IsApplyingConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsApplyingConfigReply, error)
	// Listener commands.
	ListListeners(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListListenersReply, error)
	AddListener(ctx context.Context, in *Listener, opts ...grpc.CallOption) (*Empty, error)
	RemoveListener(ctx context.Context, in *ListenerRequestWithName, opts ...grpc.CallOption) (*Empty, error)
	SetListenerMaxMessageSize(ctx context.Context, in *ListenerMaxMessageSizeRequest, opts ...grpc.CallOption) (*Empty, error)
	GetListenerMaxMessageSize(ctx context.Context, in *ListenerRequestWithName, opts ...grpc.CallOption) (*ListenerMaxMessageSizeReply, error)
	// Interface commands.
	ListInterfaces(ctx context.Context, in *ListenerRequestWithName, opts ...grpc.CallOption) (*ListInterfacesReply, error)
	AddInterface(ctx context.Context, in *AddInterfaceRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveInterface(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*Empty, error)
	SetInterfaceMTU(ctx context.Context, in *InterfaceMTURequest, opts ...grpc.CallOption) (*Empty, error)
	GetInterfaceMTU(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceMTUReply, error)
	SetInterfaceMACAddress(ctx context.Context, in *InterfaceMACAddressRequest, opts ...grpc.CallOption) (*Empty, error)
	GetInterfaceMACAddress(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceMACAddressReply, error)
	SetInterfaceIPAddresses(ctx context.Context, in *InterfaceIPAddressesRequest, opts ...grpc.CallOption) (*Empty, error)
	GetInterfaceIPAddresses(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceIPAddressesReply, error)
	InterfaceAddMACEntry(ctx context.Context, in *InterfaceMacEntryRequest, opts ...grpc.CallOption) (*Empty, error)
	InterfaceRemoveMACEntry(ctx context.Context, in *InterfaceRemoveMacEntryRequest, opts ...grpc.CallOption) (*Empty, error)
	InterfaceGetMACEntries(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceMacEntryReply, error)
	InterfaceFlushMACTable(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*Empty, error)
	InterfaceAddStaticRoute(ctx context.Context, in *InterfaceAddStaticRouteRequest, opts ...grpc.CallOption) (*Empty, error)
	InterfaceRemoveStaticRoute(ctx context.Context, in *InterfaceRemoveStaticRouteRequest, opts ...grpc.CallOption) (*Empty, error)
	InterfaceGetStaticRoutes(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceStaticRouteReply, error)
	InterfaceAddStaticARPEntry(ctx context.Context, in *InterfaceARPEntryRequest, opts ...grpc.CallOption) (*Empty, error)
	InterfaceRemoveARPEntry(ctx context.Context, in *InterfaceRemoveARPEntryRequest, opts ...grpc.CallOption) (*Empty, error)
	InterfaceGetARPEntries(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceArpEntryReply, error)
	InterfaceFlushARPTable(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*Empty, error)
}

type vxlanClient struct {
	cc grpc.ClientConnInterface
}

func NewVxlanClient(cc grpc.ClientConnInterface) VxlanClient {
	return &vxlanClient{cc}
}

func (c *vxlanClient) SaveConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_SaveConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) ReloadConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_ReloadConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) IsApplyingConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsApplyingConfigReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsApplyingConfigReply)
	err := c.cc.Invoke(ctx, Vxlan_IsApplyingConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) ListListeners(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListListenersReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListListenersReply)
	err := c.cc.Invoke(ctx, Vxlan_ListListeners_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) AddListener(ctx context.Context, in *Listener, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_AddListener_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) RemoveListener(ctx context.Context, in *ListenerRequestWithName, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_RemoveListener_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) SetListenerMaxMessageSize(ctx context.Context, in *ListenerMaxMessageSizeRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_SetListenerMaxMessageSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) GetListenerMaxMessageSize(ctx context.Context, in *ListenerRequestWithName, opts ...grpc.CallOption) (*ListenerMaxMessageSizeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListenerMaxMessageSizeReply)
	err := c.cc.Invoke(ctx, Vxlan_GetListenerMaxMessageSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) ListInterfaces(ctx context.Context, in *ListenerRequestWithName, opts ...grpc.CallOption) (*ListInterfacesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInterfacesReply)
	err := c.cc.Invoke(ctx, Vxlan_ListInterfaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) AddInterface(ctx context.Context, in *AddInterfaceRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_AddInterface_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) RemoveInterface(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_RemoveInterface_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) SetInterfaceMTU(ctx context.Context, in *InterfaceMTURequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_SetInterfaceMTU_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) GetInterfaceMTU(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceMTUReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceMTUReply)
	err := c.cc.Invoke(ctx, Vxlan_GetInterfaceMTU_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) SetInterfaceMACAddress(ctx context.Context, in *InterfaceMACAddressRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_SetInterfaceMACAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) GetInterfaceMACAddress(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceMACAddressReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceMACAddressReply)
	err := c.cc.Invoke(ctx, Vxlan_GetInterfaceMACAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) SetInterfaceIPAddresses(ctx context.Context, in *InterfaceIPAddressesRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_SetInterfaceIPAddresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) GetInterfaceIPAddresses(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceIPAddressesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceIPAddressesReply)
	err := c.cc.Invoke(ctx, Vxlan_GetInterfaceIPAddresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceAddMACEntry(ctx context.Context, in *InterfaceMacEntryRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceAddMACEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceRemoveMACEntry(ctx context.Context, in *InterfaceRemoveMacEntryRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceRemoveMACEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceGetMACEntries(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceMacEntryReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceMacEntryReply)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceGetMACEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceFlushMACTable(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceFlushMACTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceAddStaticRoute(ctx context.Context, in *InterfaceAddStaticRouteRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceAddStaticRoute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceRemoveStaticRoute(ctx context.Context, in *InterfaceRemoveStaticRouteRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceRemoveStaticRoute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceGetStaticRoutes(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceStaticRouteReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceStaticRouteReply)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceGetStaticRoutes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceAddStaticARPEntry(ctx context.Context, in *InterfaceARPEntryRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceAddStaticARPEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceRemoveARPEntry(ctx context.Context, in *InterfaceRemoveARPEntryRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceRemoveARPEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceGetARPEntries(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*InterfaceArpEntryReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceArpEntryReply)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceGetARPEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vxlanClient) InterfaceFlushARPTable(ctx context.Context, in *InterfaceRequestWithName, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vxlan_InterfaceFlushARPTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VxlanServer is the server API for Vxlan service.
// All implementations must embed UnimplementedVxlanServer
// for forward compatibility.
type VxlanServer interface {
	// Config commands.
	SaveConfig(context.Context, *Empty) (*Empty, error)
	ReloadConfig(context.Context, *Empty) (*Empty, error)
	IsApplyingConfig(context.Context, *Empty) (*IsApplyingConfigReply, error)
	// Listener commands.
	ListListeners(context.Context, *Empty) (*ListListenersReply, error)
	AddListener(context.Context, *Listener) (*Empty, error)
	RemoveListener(context.Context, *ListenerRequestWithName) (*Empty, error)
	SetListenerMaxMessageSize(context.Context, *ListenerMaxMessageSizeRequest) (*Empty, error)
	GetListenerMaxMessageSize(context.Context, *ListenerRequestWithName) (*ListenerMaxMessageSizeReply, error)
	// Interface commands.
	ListInterfaces(context.Context, *ListenerRequestWithName) (*ListInterfacesReply, error)
	AddInterface(context.Context, *AddInterfaceRequest) (*Empty, error)
	RemoveInterface(context.Context, *InterfaceRequestWithName) (*Empty, error)
	SetInterfaceMTU(context.Context, *InterfaceMTURequest) (*Empty, error)
	GetInterfaceMTU(context.Context, *InterfaceRequestWithName) (*InterfaceMTUReply, error)
	SetInterfaceMACAddress(context.Context, *InterfaceMACAddressRequest) (*Empty, error)
	GetInterfaceMACAddress(context.Context, *InterfaceRequestWithName) (*InterfaceMACAddressReply, error)
	SetInterfaceIPAddresses(context.Context, *InterfaceIPAddressesRequest) (*Empty, error)
	GetInterfaceIPAddresses(context.Context, *InterfaceRequestWithName) (*InterfaceIPAddressesReply, error)
	InterfaceAddMACEntry(context.Context, *InterfaceMacEntryRequest) (*Empty, error)
	InterfaceRemoveMACEntry(context.Context, *InterfaceRemoveMacEntryRequest) (*Empty, error)
	InterfaceGetMACEntries(context.Context, *InterfaceRequestWithName) (*InterfaceMacEntryReply, error)
	InterfaceFlushMACTable(context.Context, *InterfaceRequestWithName) (*Empty, error)
	InterfaceAddStaticRoute(context.Context, *InterfaceAddStaticRouteRequest) (*Empty, error)
	InterfaceRemoveStaticRoute(context.Context, *InterfaceRemoveStaticRouteRequest) (*Empty, error)
	InterfaceGetStaticRoutes(context.Context, *InterfaceRequestWithName) (*InterfaceStaticRouteReply, error)
	InterfaceAddStaticARPEntry(context.Context, *InterfaceARPEntryRequest) (*Empty, error)
	InterfaceRemoveARPEntry(context.Context, *InterfaceRemoveARPEntryRequest) (*Empty, error)
	InterfaceGetARPEntries(context.Context, *InterfaceRequestWithName) (*InterfaceArpEntryReply, error)
	InterfaceFlushARPTable(context.Context, *InterfaceRequestWithName) (*Empty, error)
	mustEmbedUnimplementedVxlanServer()
}

// UnimplementedVxlanServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVxlanServer struct{}

func (UnimplementedVxlanServer) SaveConfig(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveConfig not implemented")
}
func (UnimplementedVxlanServer) ReloadConfig(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadConfig not implemented")
}
func (UnimplementedVxlanServer) IsApplyingConfig(context.Context, *Empty) (*IsApplyingConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsApplyingConfig not implemented")
}
func (UnimplementedVxlanServer) ListListeners(context.Context, *Empty) (*ListListenersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListListeners not implemented")
}
func (UnimplementedVxlanServer) AddListener(context.Context, *Listener) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddListener not implemented")
}
func (UnimplementedVxlanServer) RemoveListener(context.Context, *ListenerRequestWithName) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveListener not implemented")
}
func (UnimplementedVxlanServer) SetListenerMaxMessageSize(context.Context, *ListenerMaxMessageSizeRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetListenerMaxMessageSize not implemented")
}
func (UnimplementedVxlanServer) GetListenerMaxMessageSize(context.Context, *ListenerRequestWithName) (*ListenerMaxMessageSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListenerMaxMessageSize not implemented")
}
func (UnimplementedVxlanServer) ListInterfaces(context.Context, *ListenerRequestWithName) (*ListInterfacesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInterfaces not implemented")
}
func (UnimplementedVxlanServer) AddInterface(context.Context, *AddInterfaceRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInterface not implemented")
}
func (UnimplementedVxlanServer) RemoveInterface(context.Context, *InterfaceRequestWithName) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveInterface not implemented")
}
func (UnimplementedVxlanServer) SetInterfaceMTU(context.Context, *InterfaceMTURequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInterfaceMTU not implemented")
}
func (UnimplementedVxlanServer) GetInterfaceMTU(context.Context, *InterfaceRequestWithName) (*InterfaceMTUReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceMTU not implemented")
}
func (UnimplementedVxlanServer) SetInterfaceMACAddress(context.Context, *InterfaceMACAddressRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInterfaceMACAddress not implemented")
}
func (UnimplementedVxlanServer) GetInterfaceMACAddress(context.Context, *InterfaceRequestWithName) (*InterfaceMACAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceMACAddress not implemented")
}
func (UnimplementedVxlanServer) SetInterfaceIPAddresses(context.Context, *InterfaceIPAddressesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInterfaceIPAddresses not implemented")
}
func (UnimplementedVxlanServer) GetInterfaceIPAddresses(context.Context, *InterfaceRequestWithName) (*InterfaceIPAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceIPAddresses not implemented")
}
func (UnimplementedVxlanServer) InterfaceAddMACEntry(context.Context, *InterfaceMacEntryRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceAddMACEntry not implemented")
}
func (UnimplementedVxlanServer) InterfaceRemoveMACEntry(context.Context, *InterfaceRemoveMacEntryRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceRemoveMACEntry not implemented")
}
func (UnimplementedVxlanServer) InterfaceGetMACEntries(context.Context, *InterfaceRequestWithName) (*InterfaceMacEntryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceGetMACEntries not implemented")
}
func (UnimplementedVxlanServer) InterfaceFlushMACTable(context.Context, *InterfaceRequestWithName) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceFlushMACTable not implemented")
}
func (UnimplementedVxlanServer) InterfaceAddStaticRoute(context.Context, *InterfaceAddStaticRouteRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceAddStaticRoute not implemented")
}
func (UnimplementedVxlanServer) InterfaceRemoveStaticRoute(context.Context, *InterfaceRemoveStaticRouteRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceRemoveStaticRoute not implemented")
}
func (UnimplementedVxlanServer) InterfaceGetStaticRoutes(context.Context, *InterfaceRequestWithName) (*InterfaceStaticRouteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceGetStaticRoutes not implemented")
}
func (UnimplementedVxlanServer) InterfaceAddStaticARPEntry(context.Context, *InterfaceARPEntryRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceAddStaticARPEntry not implemented")
}
func (UnimplementedVxlanServer) InterfaceRemoveARPEntry(context.Context, *InterfaceRemoveARPEntryRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceRemoveARPEntry not implemented")
}
func (UnimplementedVxlanServer) InterfaceGetARPEntries(context.Context, *InterfaceRequestWithName) (*InterfaceArpEntryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceGetARPEntries not implemented")
}
func (UnimplementedVxlanServer) InterfaceFlushARPTable(context.Context, *InterfaceRequestWithName) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceFlushARPTable not implemented")
}
func (UnimplementedVxlanServer) mustEmbedUnimplementedVxlanServer() {}
func (UnimplementedVxlanServer) testEmbeddedByValue()               {}

// UnsafeVxlanServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VxlanServer will
// result in compilation errors.
type UnsafeVxlanServer interface {
	mustEmbedUnimplementedVxlanServer()
}

func RegisterVxlanServer(s grpc.ServiceRegistrar, srv VxlanServer) {
	// If the following call pancis, it indicates UnimplementedVxlanServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Vxlan_ServiceDesc, srv)
}

func _Vxlan_SaveConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).SaveConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_SaveConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).SaveConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_ReloadConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).ReloadConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_ReloadConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).ReloadConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_IsApplyingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).IsApplyingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_IsApplyingConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).IsApplyingConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_ListListeners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).ListListeners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_ListListeners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).ListListeners(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_AddListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Listener)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).AddListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_AddListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).AddListener(ctx, req.(*Listener))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_RemoveListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).RemoveListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_RemoveListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).RemoveListener(ctx, req.(*ListenerRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_SetListenerMaxMessageSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerMaxMessageSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).SetListenerMaxMessageSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_SetListenerMaxMessageSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).SetListenerMaxMessageSize(ctx, req.(*ListenerMaxMessageSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_GetListenerMaxMessageSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).GetListenerMaxMessageSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_GetListenerMaxMessageSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).GetListenerMaxMessageSize(ctx, req.(*ListenerRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_ListInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).ListInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_ListInterfaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).ListInterfaces(ctx, req.(*ListenerRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_AddInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).AddInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_AddInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).AddInterface(ctx, req.(*AddInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_RemoveInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).RemoveInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_RemoveInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).RemoveInterface(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_SetInterfaceMTU_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceMTURequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).SetInterfaceMTU(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_SetInterfaceMTU_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).SetInterfaceMTU(ctx, req.(*InterfaceMTURequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_GetInterfaceMTU_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).GetInterfaceMTU(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_GetInterfaceMTU_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).GetInterfaceMTU(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_SetInterfaceMACAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceMACAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).SetInterfaceMACAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_SetInterfaceMACAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).SetInterfaceMACAddress(ctx, req.(*InterfaceMACAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_GetInterfaceMACAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).GetInterfaceMACAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_GetInterfaceMACAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).GetInterfaceMACAddress(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_SetInterfaceIPAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceIPAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).SetInterfaceIPAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_SetInterfaceIPAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).SetInterfaceIPAddresses(ctx, req.(*InterfaceIPAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_GetInterfaceIPAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).GetInterfaceIPAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_GetInterfaceIPAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).GetInterfaceIPAddresses(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceAddMACEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceMacEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceAddMACEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceAddMACEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceAddMACEntry(ctx, req.(*InterfaceMacEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceRemoveMACEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRemoveMacEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceRemoveMACEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceRemoveMACEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceRemoveMACEntry(ctx, req.(*InterfaceRemoveMacEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceGetMACEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceGetMACEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceGetMACEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceGetMACEntries(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceFlushMACTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceFlushMACTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceFlushMACTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceFlushMACTable(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceAddStaticRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceAddStaticRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceAddStaticRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceAddStaticRoute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceAddStaticRoute(ctx, req.(*InterfaceAddStaticRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceRemoveStaticRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRemoveStaticRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceRemoveStaticRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceRemoveStaticRoute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceRemoveStaticRoute(ctx, req.(*InterfaceRemoveStaticRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceGetStaticRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceGetStaticRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceGetStaticRoutes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceGetStaticRoutes(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceAddStaticARPEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceARPEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceAddStaticARPEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceAddStaticARPEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceAddStaticARPEntry(ctx, req.(*InterfaceARPEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceRemoveARPEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRemoveARPEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceRemoveARPEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceRemoveARPEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceRemoveARPEntry(ctx, req.(*InterfaceRemoveARPEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceGetARPEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceGetARPEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceGetARPEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceGetARPEntries(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vxlan_InterfaceFlushARPTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequestWithName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VxlanServer).InterfaceFlushARPTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vxlan_InterfaceFlushARPTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VxlanServer).InterfaceFlushARPTable(ctx, req.(*InterfaceRequestWithName))
	}
	return interceptor(ctx, in, info, handler)
}

// Vxlan_ServiceDesc is the grpc.ServiceDesc for Vxlan service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vxlan_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vxlan.vxlan",
	HandlerType: (*VxlanServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveConfig",
			Handler:    _Vxlan_SaveConfig_Handler,
		},
		{
			MethodName: "ReloadConfig",
			Handler:    _Vxlan_ReloadConfig_Handler,
		},
		{
			MethodName: "IsApplyingConfig",
			Handler:    _Vxlan_IsApplyingConfig_Handler,
		},
		{
			MethodName: "ListListeners",
			Handler:    _Vxlan_ListListeners_Handler,
		},
		{
			MethodName: "AddListener",
			Handler:    _Vxlan_AddListener_Handler,
		},
		{
			MethodName: "RemoveListener",
			Handler:    _Vxlan_RemoveListener_Handler,
		},
		{
			MethodName: "SetListenerMaxMessageSize",
			Handler:    _Vxlan_SetListenerMaxMessageSize_Handler,
		},
		{
			MethodName: "GetListenerMaxMessageSize",
			Handler:    _Vxlan_GetListenerMaxMessageSize_Handler,
		},
		{
			MethodName: "ListInterfaces",
			Handler:    _Vxlan_ListInterfaces_Handler,
		},
		{
			MethodName: "AddInterface",
			Handler:    _Vxlan_AddInterface_Handler,
		},
		{
			MethodName: "RemoveInterface",
			Handler:    _Vxlan_RemoveInterface_Handler,
		},
		{
			MethodName: "SetInterfaceMTU",
			Handler:    _Vxlan_SetInterfaceMTU_Handler,
		},
		{
			MethodName: "GetInterfaceMTU",
			Handler:    _Vxlan_GetInterfaceMTU_Handler,
		},
		{
			MethodName: "SetInterfaceMACAddress",
			Handler:    _Vxlan_SetInterfaceMACAddress_Handler,
		},
		{
			MethodName: "GetInterfaceMACAddress",
			Handler:    _Vxlan_GetInterfaceMACAddress_Handler,
		},
		{
			MethodName: "SetInterfaceIPAddresses",
			Handler:    _Vxlan_SetInterfaceIPAddresses_Handler,
		},
		{
			MethodName: "GetInterfaceIPAddresses",
			Handler:    _Vxlan_GetInterfaceIPAddresses_Handler,
		},
		{
			MethodName: "InterfaceAddMACEntry",
			Handler:    _Vxlan_InterfaceAddMACEntry_Handler,
		},
		{
			MethodName: "InterfaceRemoveMACEntry",
			Handler:    _Vxlan_InterfaceRemoveMACEntry_Handler,
		},
		{
			MethodName: "InterfaceGetMACEntries",
			Handler:    _Vxlan_InterfaceGetMACEntries_Handler,
		},
		{
			MethodName: "InterfaceFlushMACTable",
			Handler:    _Vxlan_InterfaceFlushMACTable_Handler,
		},
		{
			MethodName: "InterfaceAddStaticRoute",
			Handler:    _Vxlan_InterfaceAddStaticRoute_Handler,
		},
		{
			MethodName: "InterfaceRemoveStaticRoute",
			Handler:    _Vxlan_InterfaceRemoveStaticRoute_Handler,
		},
		{
			MethodName: "InterfaceGetStaticRoutes",
			Handler:    _Vxlan_InterfaceGetStaticRoutes_Handler,
		},
		{
			MethodName: "InterfaceAddStaticARPEntry",
			Handler:    _Vxlan_InterfaceAddStaticARPEntry_Handler,
		},
		{
			MethodName: "InterfaceRemoveARPEntry",
			Handler:    _Vxlan_InterfaceRemoveARPEntry_Handler,
		},
		{
			MethodName: "InterfaceGetARPEntries",
			Handler:    _Vxlan_InterfaceGetARPEntries_Handler,
		},
		{
			MethodName: "InterfaceFlushARPTable",
			Handler:    _Vxlan_InterfaceFlushARPTable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vxlan/vxlan.proto",
}
